const RESET = '\x1b[0m';
const RED = '\x1b[0;31m';
const GREEN = '\x1b[0;32m';
const YELLOW = '\x1b[0;33m';
const BOLD = '\x1b[1m';
const GLib = imports.gi.GLib;
const GFormat = imports.format;
const util = process.binding('util');
const inspect = arg => typeof arg === 'string' ? arg : util.inspect(arg);
const show = (fn, pre, args, post) => {
  fn(pre + (
    /%[sdxf]/.test(args[0]) ?
      GFormat.vprintf(args[0], args.slice(1)) :
      args.map(inspect).join(' ')
  ) + post);
};
const timers = Object.create(null);
const console = {
  assert: function assert(what, why) {
    if (!what) {
      imports.jsUnit.error(
        RED + BOLD + '[WRONG]' + RESET + ' ' + RED + BOLD + (why || '') + RESET
      );
    }
  },
  error: function error(what, why) {
    show(
      printerr,
      RED + BOLD + '[ERROR]' + RESET + ' ' + RED,
      util.slice.apply(0, arguments),
      RESET
    );
  },
  info: function info(what, why) {
    show(
      print,
      GREEN + BOLD + '[INFO]' + RESET + ' ' + BOLD,
      util.slice.apply(0, arguments),
      RESET
    );
  },
  log: function log(what, why) {
    show(
      print,
      '',
      util.slice.apply(0, arguments),
      ''
    );
  },
  time: function time(name) {
    timers[name] = GLib.get_real_time();
  },
  timeEnd: function timeEnd(name) {
    let result = (GLib.get_real_time() - timers[name]) / 1000;
    delete timers[name];
    console.log(name + ': ' + result + 'ms');
  },
  warn: function warn(what, why) {
    show(
      print,
      YELLOW + BOLD + '[WARNING]' + RESET + ' ' + YELLOW,
      util.slice.apply(0, arguments),
      RESET
    );
  }
};
Object.defineProperty(
  global,
  'console',
  {enumerable: true, value: console}
);

module.exports = console;
